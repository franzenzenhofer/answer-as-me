{"version":3,"file":"context-extractor.js","sourceRoot":"","sources":["../../../src/modules/context-extractor.ts"],"names":[],"mappings":"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","sourcesContent":["namespace ContextExtractor {\n  /**\n   * Extract context from email thread\n   */\n  export function extractThreadContext(\n    thread: GoogleAppsScript.Gmail.GmailThread,\n    currentMessageId: string\n  ): Types.EmailContext {\n    const messages = thread.getMessages();\n    const currentIndex = messages.findIndex(m => m.getId() === currentMessageId);\n    \n    if (currentIndex === -1) {\n      throw new ErrorHandling.AppError(\n        'Message not found in thread',\n        'MESSAGE_NOT_FOUND'\n      );\n    }\n    \n    const currentMessage = messages[currentIndex];\n    if (!currentMessage) {\n      throw new ErrorHandling.AppError(\n        'Message not found at index',\n        'MESSAGE_NOT_FOUND'\n      );\n    }\n    \n    // Get previous messages for context (limit to prevent memory issues)\n    const previousMessages: Types.EmailMessage[] = [];\n    const maxContextMessages = Math.min(Constants.EMAIL.MAX_CONTEXT_MESSAGES, 10);\n    const startIndex = Math.max(0, currentIndex - maxContextMessages);\n    \n    for (let i = startIndex; i < currentIndex; i++) {\n      const msg = messages[i];\n      if (msg) {\n        const plainBody = msg.getPlainBody();\n        // Limit body size to prevent memory issues\n        const truncatedBody = plainBody.length > 5000 ? \n          `${plainBody.substring(0, 5000)  }... [truncated]` : plainBody;\n        \n        previousMessages.push({\n          from: msg.getFrom(),\n          to: msg.getTo(),\n          date: msg.getDate(),\n          body: Utils.cleanEmailBody(truncatedBody)\n        });\n      }\n    }\n    \n    return {\n      threadId: thread.getId(),\n      messageId: currentMessageId,\n      from: currentMessage.getFrom(),\n      to: currentMessage.getTo(),\n      subject: currentMessage.getSubject(),\n      body: Utils.cleanEmailBody(currentMessage.getPlainBody()),\n      date: currentMessage.getDate(),\n      isReply: currentIndex > 0,\n      previousMessages\n    };\n  }\n  \n  /**\n   * Extract key information from email\n   */\n  export function extractKeyInfo(emailBody: string): {\n    hasQuestion: boolean;\n    topics: string[];\n    sentiment: string;\n  } {\n    // Check for questions\n    const hasQuestion = /\\?|^(what|where|when|why|how|who|which|could|would|should|can|will)/im.test(emailBody);\n    \n    // Extract potential topics (simple keyword extraction with memory optimization)\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'them', 'their', 'what', 'which', 'who', 'when', 'where', 'why', 'how']);\n    \n    // Limit text size to prevent memory issues\n    const textToAnalyze = emailBody.length > 10000 ? \n      emailBody.substring(0, 10000) : emailBody;\n    \n    // Use Map for better memory management and limit total unique words\n    const topicCounts = new Map<string, number>();\n    const words = textToAnalyze.toLowerCase().split(/\\s+/);\n    \n    for (const word of words) {\n      if (word.length > 4 && !stopWords.has(word)) {\n        topicCounts.set(word, (topicCounts.get(word) || 0) + 1);\n        \n        // Limit map size to prevent memory issues\n        if (topicCounts.size > 100) {\n          // Remove least frequent words\n          const entries = Array.from(topicCounts.entries());\n          entries.sort((a, b) => a[1] - b[1]);\n          if (entries[0]) {\n            topicCounts.delete(entries[0][0]);\n          }\n        }\n      }\n    }\n    \n    // Convert to array and get top topics\n    const topTopics = Array.from(topicCounts.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(entry => entry[0]);\n    \n    // Simple sentiment detection\n    const positiveWords = (emailBody.match(/\\b(good|great|excellent|wonderful|fantastic|appreciate|thanks|thank you|pleased|happy)\\b/gi) || []).length;\n    const negativeWords = (emailBody.match(/\\b(bad|poor|terrible|awful|disappointed|unhappy|problem|issue|concern|complaint)\\b/gi) || []).length;\n    \n    let sentiment = 'neutral';\n    if (positiveWords > negativeWords * 2) {\n      sentiment = 'positive';\n    } else if (negativeWords > positiveWords * 2) {\n      sentiment = 'negative';\n    }\n    \n    return {\n      hasQuestion,\n      topics: topTopics,\n      sentiment\n    };\n  }\n}"]}